# Implementation Plan: Codegen Upgrade v·ªõi Jennifer

## M·ª•c Ti√™u
N√¢ng c·∫•p go-carbon codegen t·ª´ string templates sang Jennifer code generator, h·ªçc t·∫≠p t·ª´ anchor-go.

## üéØ Phase 1: Setup & Architecture (Day 1-2)

### 1.1. Dependencies
```bash
# Add jennifer
go get github.com/dave/jennifer/jen

# Add borsh encoder/decoder if not exists
go get github.com/gagliardetto/binary
```

### 1.2. File Structure
```
internal/codegen/
‚îú‚îÄ‚îÄ generator.go              # Main orchestrator (refactor existing)
‚îú‚îÄ‚îÄ idl.go                   # Keep as-is (IDL type definitions)
‚îú‚îÄ‚îÄ parser.go                # Keep as-is (IDL parsing)
‚îÇ
‚îú‚îÄ‚îÄ gen/                     # New: Generation modules
‚îÇ   ‚îú‚îÄ‚îÄ base.go             # Base generator with jennifer helpers
‚îÇ   ‚îú‚îÄ‚îÄ instructions.go     # Instruction generation
‚îÇ   ‚îú‚îÄ‚îÄ accounts.go         # Account generation
‚îÇ   ‚îú‚îÄ‚îÄ events.go           # Event generation
‚îÇ   ‚îú‚îÄ‚îÄ types.go            # Type definitions generation
‚îÇ   ‚îú‚îÄ‚îÄ discriminators.go   # Discriminator generation
‚îÇ   ‚îú‚îÄ‚îÄ marshal.go          # Borsh marshal methods
‚îÇ   ‚îú‚îÄ‚îÄ unmarshal.go        # Borsh unmarshal methods
‚îÇ   ‚îú‚îÄ‚îÄ program.go          # Program metadata
‚îÇ   ‚îî‚îÄ‚îÄ utils.go            # Shared utilities
‚îÇ
‚îî‚îÄ‚îÄ testdata/               # Test IDL files
    ‚îú‚îÄ‚îÄ simple.json
    ‚îú‚îÄ‚îÄ complex_enums.json
    ‚îî‚îÄ‚îÄ full_features.json
```

### 1.3. Base Generator Setup

**File: `internal/codegen/gen/base.go`**
```go
package gen

import (
    . "github.com/dave/jennifer/jen"
    "github.com/lugondev/go-carbon/internal/codegen"
)

// Package constants for common imports
const (
    PkgSolanaGo = "github.com/gagliardetto/solana-go"
    PkgBinary   = "github.com/gagliardetto/binary"
    PkgContext  = "context"
    PkgFmt      = "fmt"
)

// BaseGenerator contains common generation utilities
type BaseGenerator struct {
    IDL         *codegen.IDL
    PackageName string
}

// NewBaseGenerator creates a new base generator
func NewBaseGenerator(idl *codegen.IDL, packageName string) *BaseGenerator {
    return &BaseGenerator{
        IDL:         idl,
        PackageName: packageName,
    }
}

// NewFile creates a new file with standard header
func (g *BaseGenerator) NewFile(filename string) *File {
    file := NewFile(g.PackageName)
    file.HeaderComment("Code generated by go-carbon codegen. DO NOT EDIT.")
    file.HeaderComment(fmt.Sprintf("Source: %s", filename))
    return file
}

// OutputFile represents a generated file
type OutputFile struct {
    Name string
    File *File
}

// ResolveType converts IDL type to Go type using jennifer
func (g *BaseGenerator) ResolveType(t codegen.IDLType) *Statement {
    // Primitive types
    if t.Kind != "" {
        return g.resolvePrimitiveType(t.Kind)
    }
    
    // Option type
    if t.Option != nil {
        inner := g.ResolveType(*t.Option)
        return Op("*").Add(inner)
    }
    
    // Vec type
    if t.Vec != nil {
        inner := g.ResolveType(*t.Vec)
        return Index().Add(inner)
    }
    
    // Array type
    if t.Array != nil {
        inner := g.ResolveType(t.Array.Type)
        return Index(Lit(t.Array.Len)).Add(inner)
    }
    
    // Defined type
    if t.Defined != nil {
        return Id(ToPascalCase(t.Defined.Name))
    }
    
    // Struct type (inline)
    if t.Struct != nil {
        // Handle inline structs
        return Interface()
    }
    
    // Enum type (inline)
    if t.Enum != nil {
        // Handle inline enums
        return Interface()
    }
    
    // Tuple type
    if len(t.Tuple) > 0 {
        // Handle tuples
        return Interface()
    }
    
    return Interface() // fallback
}

func (g *BaseGenerator) resolvePrimitiveType(kind string) *Statement {
    switch kind {
    case "bool":
        return Bool()
    case "u8":
        return Uint8()
    case "u16":
        return Uint16()
    case "u32":
        return Uint32()
    case "u64":
        return Uint64()
    case "u128":
        return Qual(PkgBinary, "Uint128")
    case "i8":
        return Int8()
    case "i16":
        return Int16()
    case "i32":
        return Int32()
    case "i64":
        return Int64()
    case "i128":
        return Qual(PkgBinary, "Int128")
    case "f32":
        return Float32()
    case "f64":
        return Float64()
    case "string":
        return String()
    case "bytes":
        return Index().Byte()
    case "pubkey", "publicKey":
        return Qual(PkgSolanaGo, "PublicKey")
    default:
        return Interface()
    }
}

// Naming utilities
func ToPascalCase(s string) string {
    // Implementation from current generator
}

func ToCamelCase(s string) string {
    // Implementation from current generator
}

func ToSnakeCase(s string) string {
    // Implementation from current generator
}
```

## üìã Phase 2: Instructions Generation (Day 3-4)

### 2.1. Instruction Builder

**File: `internal/codegen/gen/instructions.go`**
```go
package gen

import (
    . "github.com/dave/jennifer/jen"
    "github.com/lugondev/go-carbon/internal/codegen"
)

type InstructionGenerator struct {
    *BaseGenerator
}

func NewInstructionGenerator(base *BaseGenerator) *InstructionGenerator {
    return &InstructionGenerator{BaseGenerator: base}
}

func (g *InstructionGenerator) Generate() (*OutputFile, error) {
    file := g.NewFile("instructions.go")
    
    // Generate instruction builder functions
    for _, ix := range g.IDL.Instructions {
        file.Add(g.generateInstructionBuilder(ix))
        file.Line().Line()
    }
    
    // Generate instruction types
    for _, ix := range g.IDL.Instructions {
        file.Add(g.generateInstructionType(ix))
        file.Line().Line()
    }
    
    // Generate instruction parser
    file.Add(g.generateInstructionParser())
    
    return &OutputFile{
        Name: "instructions.go",
        File: file,
    }, nil
}

func (g *InstructionGenerator) generateInstructionBuilder(ix codegen.IDLInstruction) Code {
    ixName := ToPascalCase(ix.Name)
    funcName := "New" + ixName + "Instruction"
    
    code := Empty()
    
    // Add documentation
    code.Comment(fmt.Sprintf("%s builds a %q instruction.", funcName, ix.Name))
    for _, doc := range ix.Docs {
        code.Comment(doc)
    }
    code.Line()
    
    // Function signature
    code.Func().Id(funcName).
        ParamsFunc(func(params *Group) {
            // Add instruction arguments
            if len(ix.Args) > 0 {
                params.Comment("Instruction arguments:")
            }
            for _, arg := range ix.Args {
                paramName := ToCamelCase(arg.Name) + "Param"
                paramType := g.ResolveType(arg.Type)
                params.Id(paramName).Add(paramType)
            }
            
            // Add accounts
            if len(ix.Accounts) > 0 {
                params.Line().Comment("Accounts:")
            }
            for _, acc := range ix.Accounts {
                accountName := ToCamelCase(acc.Name) + "Account"
                params.Id(accountName).Qual(PkgSolanaGo, "PublicKey")
            }
        }).
        Params(
            Qual(PkgSolanaGo, "Instruction"),
            Error(),
        ).
        BlockFunc(func(body *Group) {
            g.generateInstructionBuilderBody(body, ix)
        })
    
    return code
}

func (g *InstructionGenerator) generateInstructionBuilderBody(body *Group, ix codegen.IDLInstruction) {
    // Validate accounts
    body.Comment("Validate required accounts")
    for _, acc := range ix.Accounts {
        if !acc.Optional {
            accountName := ToCamelCase(acc.Name) + "Account"
            body.If(Id(accountName).Dot("IsZero").Call()).Block(
                Return(
                    Nil(),
                    Qual(PkgFmt, "Errorf").Call(Lit(fmt.Sprintf("%s account is required", acc.Name))),
                ),
            )
        }
    }
    
    // Encode instruction data
    if len(ix.Args) > 0 {
        body.Line()
        body.Comment("Encode instruction data")
        body.Id("buf").Op(":=").New(Qual("bytes", "Buffer"))
        body.Id("enc").Op(":=").Qual(PkgBinary, "NewBorshEncoder").Call(Id("buf"))
        
        // Write discriminator
        body.Line()
        body.Comment("Write instruction discriminator")
        discName := ixName + "InstructionDiscriminator"
        body.If(
            Err().Op(":=").Id("enc").Dot("WriteBytes").Call(
                Id(discName).Index(Op(":")),
                False(),
            ),
            Err().Op("!=").Nil(),
        ).Block(
            Return(
                Nil(),
                Qual(PkgFmt, "Errorf").Call(Lit("failed to write discriminator: %w"), Err()),
            ),
        )
        
        // Encode each argument
        for _, arg := range ix.Args {
            paramName := ToCamelCase(arg.Name) + "Param"
            body.Line()
            body.Comment(fmt.Sprintf("Encode argument: %s", arg.Name))
            
            // Handle Option types
            if arg.Type.Option != nil {
                body.If(Id(paramName).Op("!=").Nil()).Block(
                    If(
                        Err().Op(":=").Id("enc").Dot("WriteOption").Call(True()),
                        Err().Op("!=").Nil(),
                    ).Block(
                        Return(Nil(), Err()),
                    ),
                    If(
                        Err().Op(":=").Id("enc").Dot("Encode").Call(Op("*").Id(paramName)),
                        Err().Op("!=").Nil(),
                    ).Block(
                        Return(Nil(), Qual(PkgFmt, "Errorf").Call(
                            Lit(fmt.Sprintf("failed to encode %s: %%w", arg.Name)),
                            Err(),
                        )),
                    ),
                ).Else().Block(
                    If(
                        Err().Op(":=").Id("enc").Dot("WriteOption").Call(False()),
                        Err().Op("!=").Nil(),
                    ).Block(
                        Return(Nil(), Err()),
                    ),
                )
            } else {
                // Regular encoding
                body.If(
                    Err().Op(":=").Id("enc").Dot("Encode").Call(Id(paramName)),
                    Err().Op("!=").Nil(),
                ).Block(
                    Return(
                        Nil(),
                        Qual(PkgFmt, "Errorf").Call(
                            Lit(fmt.Sprintf("failed to encode %s: %%w", arg.Name)),
                            Err(),
                        ),
                    ),
                )
            }
        }
    }
    
    // Build account metas
    body.Line()
    body.Comment("Build account metas")
    body.Id("accounts").Op(":=").Qual(PkgSolanaGo, "AccountMetaSlice").Block()
    
    for i, acc := range ix.Accounts {
        accountName := ToCamelCase(acc.Name) + "Account"
        body.Line()
        body.Comment(fmt.Sprintf("Account %d: %s", i, acc.Name))
        body.Id("accounts").Dot("Append").Call(
            Qual(PkgSolanaGo, "NewAccountMeta").Call(
                Id(accountName),
                Lit(acc.Writable),
                Lit(acc.Signer),
            ),
        )
    }
    
    // Create instruction
    body.Line()
    body.Comment("Create instruction")
    body.Return(
        Qual(PkgSolanaGo, "NewInstruction").Call(
            Id("ProgramID"),
            Id("accounts"),
            Do(func(s *Statement) {
                if len(ix.Args) > 0 {
                    s.Id("buf").Dot("Bytes").Call()
                } else {
                    s.Nil()
                }
            }),
        ),
        Nil(),
    )
}

func (g *InstructionGenerator) generateInstructionType(ix codegen.IDLInstruction) Code {
    ixName := ToPascalCase(ix.Name) + "Instruction"
    
    code := Empty()
    code.Comment(fmt.Sprintf("%s represents the %q instruction.", ixName, ix.Name))
    code.Type().Id(ixName).StructFunc(func(fields *Group) {
        // Add instruction arguments
        if len(ix.Args) > 0 {
            fields.Comment("Instruction arguments:")
        }
        for _, arg := range ix.Args {
            fieldName := ToPascalCase(arg.Name)
            fieldType := g.ResolveType(arg.Type)
            jsonTag := ToSnakeCase(arg.Name)
            
            fields.Id(fieldName).Add(fieldType).Tag(map[string]string{
                "json":  jsonTag,
                "borsh": jsonTag,
            })
        }
        
        // Add accounts
        if len(ix.Accounts) > 0 {
            fields.Line().Comment("Accounts:")
        }
        for _, acc := range ix.Accounts {
            fieldName := ToPascalCase(acc.Name)
            jsonTag := ToSnakeCase(acc.Name)
            
            fields.Id(fieldName).Qual(PkgSolanaGo, "PublicKey").Tag(map[string]string{
                "json": jsonTag,
            })
        }
    })
    
    return code
}

func (g *InstructionGenerator) generateInstructionParser() Code {
    code := Empty()
    
    code.Comment("Instruction interface for all instruction types")
    code.Type().Id("Instruction").Interface(
        Id("GetDiscriminator").Params().Params(Index().Byte()),
    )
    
    code.Line().Line()
    code.Comment("ParseInstruction parses instruction data")
    code.Func().Id("ParseInstruction").
        Params(
            Id("data").Index().Byte(),
        ).
        Params(Id("Instruction"), Error()).
        BlockFunc(func(body *Group) {
            // Check minimum length
            body.If(Len(Id("data")).Op("<").Lit(8)).Block(
                Return(
                    Nil(),
                    Qual(PkgFmt, "Errorf").Call(Lit("instruction data too short")),
                ),
            )
            
            // Extract discriminator
            body.Line()
            body.Var().Id("disc").Index(Lit(8)).Byte()
            body.Copy(Id("disc").Index(Op(":")), Id("data").Index(Lit(0), Lit(8)))
            
            // Switch on discriminator
            body.Line()
            body.Switch(Id("disc")).BlockFunc(func(switchBlock *Group) {
                for _, ix := range g.IDL.Instructions {
                    ixName := ToPascalCase(ix.Name)
                    discName := ixName + "InstructionDiscriminator"
                    typeName := ixName + "Instruction"
                    
                    switchBlock.Case(Id(discName)).Block(
                        Id("instruction").Op(":=").New(Id(typeName)),
                        Comment("TODO: Unmarshal instruction data"),
                        Return(Id("instruction"), Nil()),
                    )
                }
                
                switchBlock.Default().Block(
                    Return(
                        Nil(),
                        Qual(PkgFmt, "Errorf").Call(Lit("unknown instruction discriminator")),
                    ),
                )
            })
        })
    
    return code
}
```

### 2.2. Usage Example

**After implementation:**
```go
// Generated code usage
import "yourproject/generated/tokenswap"

func main() {
    // Build instruction with type-safe parameters
    ix, err := tokenswap.NewSwapInstruction(
        1000000,          // amountIn
        nil,              // minAmountOut (optional)
        swapAccount,      // swap account
        userAccount,      // user account  
        tokenMintAccount, // token mint account
    )
    if err != nil {
        log.Fatal(err)
    }
    
    // Use instruction
    tx := solana.NewTransaction([]solana.Instruction{ix}, ...)
}
```

## üß™ Testing Strategy

### Unit Tests
```go
// internal/codegen/gen/instructions_test.go
func TestInstructionGeneration(t *testing.T) {
    idl := &codegen.IDL{
        Instructions: []codegen.IDLInstruction{
            {
                Name: "initialize",
                Args: []codegen.IDLField{
                    {Name: "amount", Type: codegen.IDLType{Kind: "u64"}},
                },
                Accounts: []codegen.IDLAccountMeta{
                    {Name: "swap", Writable: true, Signer: false},
                },
            },
        },
    }
    
    gen := NewInstructionGenerator(NewBaseGenerator(idl, "test"))
    output, err := gen.Generate()
    require.NoError(t, err)
    require.NotNil(t, output)
    
    // Verify generated code compiles
    code := output.File.GoString()
    _, err = format.Source([]byte(code))
    require.NoError(t, err)
}
```

### Integration Tests
```go
func TestGeneratedCodeCompiles(t *testing.T) {
    // Generate code from test IDL
    tmpDir := t.TempDir()
    err := GenerateFromIDL("testdata/simple.json", tmpDir)
    require.NoError(t, err)
    
    // Try to build generated code
    cmd := exec.Command("go", "build", "-o", "/dev/null", tmpDir)
    err = cmd.Run()
    require.NoError(t, err)
}
```

## üìä Progress Tracking

### Day 1-2: Setup
- [ ] Add jennifer dependency
- [ ] Create gen/ package structure
- [ ] Implement BaseGenerator
- [ ] Implement naming utilities
- [ ] Write base tests

### Day 3-4: Instructions
- [ ] Implement InstructionGenerator
- [ ] Generate instruction builders
- [ ] Generate instruction types
- [ ] Generate instruction parsers
- [ ] Write instruction tests

### Day 5-6: Accounts & Events
- [ ] Implement AccountGenerator
- [ ] Implement EventGenerator
- [ ] Generate discriminators
- [ ] Write tests

### Day 7-8: Types
- [ ] Implement TypeGenerator
- [ ] Handle structs
- [ ] Handle simple enums
- [ ] Handle complex enums (if time permits)
- [ ] Write tests

### Day 9: Integration
- [ ] Update main generator.go
- [ ] Wire all generators together
- [ ] Update CLI
- [ ] Integration tests

### Day 10: Testing & Polish
- [ ] Complete test coverage
- [ ] Fix bugs
- [ ] Update documentation
- [ ] Update examples

## üéØ Success Criteria

1. **Code Quality**
   - Generated code passes `go vet`
   - Generated code passes `golangci-lint`
   - Generated code is properly formatted

2. **Functionality**
   - Can generate from all test IDLs
   - Generated code compiles
   - Instruction builders work correctly
   - Parsers decode correctly

3. **Testing**
   - Unit tests for each generator
   - Integration tests pass
   - Coverage > 70%

4. **Documentation**
   - Code is well-commented
   - Examples are updated
   - README is updated

## üöÄ Next Actions

1. **Ngay b√¢y gi·ªù**: T·∫°o branch m·ªõi `feature/jennifer-codegen`
2. **Day 1 Morning**: Setup dependencies v√† base structure
3. **Day 1 Afternoon**: Implement BaseGenerator
4. **Day 2**: Start instruction generation

---

**Ready to start! üéâ**
