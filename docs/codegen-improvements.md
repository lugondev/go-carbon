# Code Generation Improvements - H·ªçc T·∫≠p T·ª´ anchor-go

## T·ªïng Quan

T√†i li·ªáu n√†y t·ªïng h·ª£p c√°c b√†i h·ªçc quan tr·ªçng t·ª´ [anchor-go](https://github.com/gagliardetto/anchor-go) v√† ƒë·ªÅ xu·∫•t c·∫£i ti·∫øn cho go-carbon codegen.

## üéØ ƒêi·ªÉm M·∫°nh C·ªßa anchor-go C·∫ßn H·ªçc T·∫≠p

### 1. **S·ª≠ d·ª•ng Jennifer Code Generator**

anchor-go s·ª≠ d·ª•ng [dave/jennifer](https://github.com/dave/jennifer) thay v√¨ string templates:

**∆Øu ƒëi·ªÉm:**
- Type-safe code generation
- T·ª± ƒë·ªông format code ƒë√∫ng chu·∫©n Go
- D·ªÖ maintain v√† refactor
- Tr√°nh l·ªói c√∫ ph√°p khi generate

**V√≠ d·ª• t·ª´ anchor-go:**
```go
// generator/instructions.go
func (g *Generator) gen_instructions() (*OutputFile, error) {
    file := NewFile(g.options.Package)
    file.HeaderComment("Code generated by anchor-go. DO NOT EDIT.")
    
    // Generate type-safe code
    code := Empty()
    code.Func().Id("NewSwapInstruction").
        Params(
            Id("amountIn").Uint64(),
            Id("accountSwap").Qual("github.com/gagliardetto/solana-go", "PublicKey"),
        ).
        Params(
            Qual("github.com/gagliardetto/solana-go", "Instruction"),
            Error(),
        ).
        Block(
            // Function body generation
        )
    
    return &OutputFile{
        Name: "instructions.go",
        File: file,
    }, nil
}
```

### 2. **Ki·∫øn Tr√∫c Module R√µ R√†ng**

```
generator/
‚îú‚îÄ‚îÄ generator.go       # Main generator orchestrator
‚îú‚îÄ‚îÄ instructions.go    # Instruction generation
‚îú‚îÄ‚îÄ accounts.go        # Account type generation  
‚îú‚îÄ‚îÄ types.go           # Custom types (struct, enum)
‚îú‚îÄ‚îÄ events.go          # Event generation
‚îú‚îÄ‚îÄ constants.go       # Constants generation
‚îú‚îÄ‚îÄ discriminator.go   # Discriminator generation
‚îú‚îÄ‚îÄ marshal.go         # Borsh marshal methods
‚îú‚îÄ‚îÄ unmarshal.go       # Borsh unmarshal methods
‚îú‚îÄ‚îÄ fetchers.go        # RPC fetcher methods
‚îî‚îÄ‚îÄ tools.go           # Helper utilities
```

**L·ª£i √≠ch:**
- Separation of concerns r√µ r√†ng
- D·ªÖ maintain t·ª´ng lo·∫°i code generation
- D·ªÖ test t·ª´ng module ƒë·ªôc l·∫≠p
- D·ªÖ extend th√™m t√≠nh nƒÉng m·ªõi

### 3. **X·ª≠ L√Ω IDL Types To√†n Di·ªán**

anchor-go c√≥ x·ª≠ l√Ω t·ªët cho:

#### a) Complex Enums (Rust-style Enums)
```go
// Enum v·ªõi variants c√≥ fields kh√°c nhau
type TransferType interface {
    IsTransferType()
}

type TransferTypeNormal struct {
    Amount uint64
}

type TransferTypeWithFee struct {
    Amount uint64
    Fee    uint64
}

func (*TransferTypeNormal) IsTransferType()  {}
func (*TransferTypeWithFee) IsTransferType() {}
```

#### b) Option v√† COption Types
```go
// Option<T> -> *T trong Go
type SwapParams struct {
    MinAmountOut *uint64 `json:"min_amount_out,omitempty" bin:"optional"`
}

// COption<T> (C-style Option) -> *T
type TokenConfig struct {
    Decimals *uint8 `json:"decimals,omitempty" bin:"coption"`
}
```

#### c) Generic Arrays v√† Vecs
```go
// Array[T; N] -> [N]T
type Buffer [256]byte

// Vec<T> -> []T
type TokenList []TokenInfo
```

#### d) Tuple Types
```go
// (T1, T2, T3) -> struct v·ªõi Item0, Item1, Item2
type PriceTuple struct {
    Item0 uint64 // price
    Item1 uint64 // timestamp
    Item2 uint8  // decimals
}
```

### 4. **Discriminator Generation T·ª± ƒê·ªông**

```go
// discriminator.go
var (
    // Account discriminators
    SwapAccountDiscriminator = [8]byte{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08}
    PoolAccountDiscriminator = [8]byte{0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18}
    
    // Event discriminators
    SwapEventDiscriminator = [8]byte{0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8}
    
    // Instruction discriminators
    InitializeDiscriminator = [8]byte{0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8}
)
```

### 5. **Generated Code Quality**

#### a) Complete Instruction Builders
```go
// Generated instruction builder with validation
func NewSwapInstruction(
    // Params:
    amountInParam uint64,
    minAmountOutParam *uint64,
    // Accounts:
    swapAccount solana.PublicKey,
    userAccount solana.PublicKey,
    tokenMintAccount solana.PublicKey,
) (solana.Instruction, error) {
    // Validate inputs
    if swapAccount.IsZero() {
        return nil, fmt.Errorf("swap account is required")
    }
    
    // Encode instruction data with discriminator
    buf := new(bytes.Buffer)
    enc := bin.NewBorshEncoder(buf)
    
    // Write discriminator
    if err := enc.WriteBytes(SwapInstructionDiscriminator[:], false); err != nil {
        return nil, fmt.Errorf("failed to write discriminator: %w", err)
    }
    
    // Encode params
    if err := enc.Encode(amountInParam); err != nil {
        return nil, fmt.Errorf("failed to encode amountIn: %w", err)
    }
    
    if minAmountOutParam != nil {
        if err := enc.WriteOption(true); err != nil {
            return nil, err
        }
        if err := enc.Encode(*minAmountOutParam); err != nil {
            return nil, err
        }
    } else {
        if err := enc.WriteOption(false); err != nil {
            return nil, err
        }
    }
    
    // Build account metas
    accounts := solana.AccountMetaSlice{}
    accounts.Append(solana.NewAccountMeta(swapAccount, true, false))
    accounts.Append(solana.NewAccountMeta(userAccount, false, true))
    accounts.Append(solana.NewAccountMeta(tokenMintAccount, false, false))
    
    return solana.NewInstruction(
        ProgramID,
        accounts,
        buf.Bytes(),
    ), nil
}
```

#### b) Instruction Parsers
```go
// Generated instruction type
type SwapInstruction struct {
    AmountIn     uint64
    MinAmountOut *uint64
    
    // Accounts:
    Swap      solana.PublicKey
    User      solana.PublicKey
    TokenMint solana.PublicKey
}

// Unified parser
func ParseInstruction(
    instructionData []byte,
    accountIndicesData []byte,
    accountKeys []solana.PublicKey,
) (Instruction, error) {
    if len(instructionData) < 8 {
        return nil, fmt.Errorf("instruction data too short")
    }
    
    discriminator := [8]byte{}
    copy(discriminator[:], instructionData[0:8])
    
    switch discriminator {
    case SwapInstructionDiscriminator:
        instruction := new(SwapInstruction)
        decoder := bin.NewBorshDecoder(instructionData)
        if err := instruction.UnmarshalWithDecoder(decoder); err != nil {
            return nil, err
        }
        // Parse and populate accounts if provided
        if accountIndicesData != nil && len(accountIndicesData) > 0 {
            indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
            if err != nil {
                return nil, err
            }
            if err := instruction.PopulateFromAccountIndices(indices, accountKeys); err != nil {
                return nil, err
            }
        }
        return instruction, nil
    default:
        return nil, fmt.Errorf("unknown instruction discriminator")
    }
}

// Instruction interface
type Instruction interface {
    GetDiscriminator() []byte
    UnmarshalWithDecoder(decoder *bin.Decoder) error
    UnmarshalAccountIndices(buf []byte) ([]uint8, error)
    PopulateFromAccountIndices(indices []uint8, accountKeys []solana.PublicKey) error
    GetAccountKeys() []solana.PublicKey
}
```

#### c) Marshal/Unmarshal Methods
```go
// MarshalWithEncoder for Borsh serialization
func (obj *SwapEvent) MarshalWithEncoder(encoder *bin.Encoder) error {
    // Encode discriminator
    if err := encoder.WriteBytes(SwapEventDiscriminator[:], false); err != nil {
        return err
    }
    
    // Encode fields
    if err := encoder.Encode(obj.User); err != nil {
        return err
    }
    if err := encoder.Encode(obj.AmountIn); err != nil {
        return err
    }
    if err := encoder.Encode(obj.AmountOut); err != nil {
        return err
    }
    
    return nil
}

// UnmarshalWithDecoder for Borsh deserialization
func (obj *SwapEvent) UnmarshalWithDecoder(decoder *bin.Decoder) error {
    // Read and validate discriminator
    discriminator, err := decoder.ReadDiscriminator()
    if err != nil {
        return err
    }
    if discriminator != SwapEventDiscriminator {
        return fmt.Errorf("discriminator mismatch")
    }
    
    // Decode fields
    if err := decoder.Decode(&obj.User); err != nil {
        return err
    }
    if err := decoder.Decode(&obj.AmountIn); err != nil {
        return err
    }
    if err := decoder.Decode(&obj.AmountOut); err != nil {
        return err
    }
    
    return nil
}
```

#### d) Account Fetchers
```go
// Generated RPC fetcher methods
func FetchSwapAccount(
    ctx context.Context,
    rpc *rpc.Client,
    address solana.PublicKey,
) (*SwapAccount, error) {
    accountInfo, err := rpc.GetAccountInfo(ctx, address)
    if err != nil {
        return nil, err
    }
    
    return ParseAccount_Swap(accountInfo.Value.Data.GetBinary())
}

func FetchMultipleSwapAccounts(
    ctx context.Context,
    rpc *rpc.Client,
    addresses []solana.PublicKey,
) ([]*SwapAccount, error) {
    accountsInfo, err := rpc.GetMultipleAccounts(ctx, addresses...)
    if err != nil {
        return nil, err
    }
    
    accounts := make([]*SwapAccount, 0, len(accountsInfo.Value))
    for _, info := range accountsInfo.Value {
        if info == nil {
            accounts = append(accounts, nil)
            continue
        }
        account, err := ParseAccount_Swap(info.Data.GetBinary())
        if err != nil {
            return nil, err
        }
        accounts = append(accounts, account)
    }
    
    return accounts, nil
}
```

### 6. **Testing Support**

```go
// tests.go - Generated test helpers
func TestSwapInstructionRoundTrip(t *testing.T) {
    // Test data
    amountIn := uint64(1000000)
    minAmountOut := uint64(950000)
    
    // Build instruction
    ix, err := NewSwapInstruction(
        amountIn,
        &minAmountOut,
        solana.MustPublicKeyFromBase58("Swap111111111111111111111111111111111111111"),
        solana.MustPublicKeyFromBase58("User111111111111111111111111111111111111111"),
        solana.MustPublicKeyFromBase58("Mint111111111111111111111111111111111111111"),
    )
    require.NoError(t, err)
    
    // Parse back
    parsed, err := ParseInstruction(ix.Data, nil, nil)
    require.NoError(t, err)
    
    swapIx, ok := parsed.(*SwapInstruction)
    require.True(t, ok)
    require.Equal(t, amountIn, swapIx.AmountIn)
    require.Equal(t, minAmountOut, *swapIx.MinAmountOut)
}
```

### 7. **Error Handling**

```go
// errors.go - Generated error types
var (
    ErrInsufficientFunds = &ProgramError{
        Code: 0x1770,
        Name: "InsufficientFunds",
        Msg:  "Insufficient funds for the operation",
    }
    
    ErrInvalidInput = &ProgramError{
        Code: 0x1771,
        Name: "InvalidInput",
        Msg:  "Invalid input parameters",
    }
)

type ProgramError struct {
    Code uint32
    Name string
    Msg  string
}

func (e *ProgramError) Error() string {
    return fmt.Sprintf("%s (%d): %s", e.Name, e.Code, e.Msg)
}

// Parse error from transaction
func ParseProgramError(logs []string) error {
    for _, log := range logs {
        if strings.Contains(log, "custom program error: 0x1770") {
            return ErrInsufficientFunds
        }
        if strings.Contains(log, "custom program error: 0x1771") {
            return ErrInvalidInput
        }
    }
    return nil
}
```

## üöÄ ƒê·ªÅ Xu·∫•t C·∫£i Ti·∫øn Cho go-carbon

### Phase 1: Refactor Architecture (2-3 ng√†y)

#### 1.1. Migrate sang Jennifer
```bash
go get github.com/dave/jennifer/jen
```

#### 1.2. T√°ch Generator th√†nh modules
```
internal/codegen/
‚îú‚îÄ‚îÄ generator.go          # Main orchestrator
‚îú‚îÄ‚îÄ idl.go               # IDL types (gi·ªØ nguy√™n)
‚îú‚îÄ‚îÄ parser.go            # Parser (gi·ªØ nguy√™n)
‚îú‚îÄ‚îÄ gen_instructions.go  # Instruction generation
‚îú‚îÄ‚îÄ gen_accounts.go      # Account generation
‚îú‚îÄ‚îÄ gen_events.go        # Event generation
‚îú‚îÄ‚îÄ gen_types.go         # Types generation
‚îú‚îÄ‚îÄ gen_program.go       # Program metadata
‚îú‚îÄ‚îÄ gen_discriminators.go # Discriminator generation
‚îú‚îÄ‚îÄ gen_marshal.go       # Borsh marshal
‚îú‚îÄ‚îÄ gen_unmarshal.go     # Borsh unmarshal
‚îî‚îÄ‚îÄ utils.go             # Shared utilities
```

### Phase 2: Enhanced Type Support (3-4 ng√†y)

#### 2.1. Complex Enum Support
```go
// gen_types.go
func (g *Generator) generateComplexEnum(name string, variants []IDLEnumVariant) *Statement {
    // Generate interface
    code := Empty()
    code.Type().Id(name).Interface(
        Id(fmt.Sprintf("Is%s", name)).Call(),
    )
    
    // Generate variant structs
    for _, variant := range variants {
        if len(variant.Fields) > 0 {
            // Complex variant with fields
            code.Type().Id(fmt.Sprintf("%s%s", name, variant.Name)).StructFunc(...)
        } else {
            // Simple variant
            code.Type().Id(fmt.Sprintf("%s%s", name, variant.Name)).Uint8()
        }
    }
    
    return code
}
```

#### 2.2. Option Type Support
```go
func (g *Generator) resolveIDLType(t IDLType) *Statement {
    if t.Option != nil {
        innerType := g.resolveIDLType(*t.Option)
        return Op("*").Add(innerType).Tag(map[string]string{
            "bin": "optional",
        })
    }
    // ... other type resolutions
}
```

#### 2.3. Tuple Support
```go
func (g *Generator) generateTupleStruct(name string, types []IDLType) *Statement {
    code := Type().Id(name).StructFunc(func(g *Group) {
        for i, t := range types {
            fieldName := fmt.Sprintf("Item%d", i)
            g.Id(fieldName).Add(resolveIDLType(t))
        }
    })
    return code
}
```

### Phase 3: Instruction Builders (2-3 ng√†y)

#### 3.1. Builder Functions
```go
// gen_instructions.go
func (g *Generator) generateInstructionBuilder(ix IDLInstruction) *Statement {
    funcName := fmt.Sprintf("New%sInstruction", toPascalCase(ix.Name))
    
    return Func().Id(funcName).
        ParamsFunc(func(params *Group) {
            // Add instruction args
            for _, arg := range ix.Args {
                params.Id(toCamelCase(arg.Name)).Add(g.resolveIDLType(arg.Type))
            }
            // Add accounts
            for _, acc := range ix.Accounts {
                params.Id(toCamelCase(acc.Name)).Qual("github.com/gagliardetto/solana-go", "PublicKey")
            }
        }).
        Params(
            Qual("github.com/gagliardetto/solana-go", "Instruction"),
            Error(),
        ).
        BlockFunc(func(body *Group) {
            // Generate function body
            g.generateInstructionBuilderBody(body, ix)
        })
}
```

#### 3.2. Instruction Parsers
```go
func (g *Generator) generateInstructionParser() *Statement {
    return Func().Id("ParseInstruction").
        Params(
            Id("data").Index().Byte(),
            Id("accountIndices").Index().Byte(),
            Id("accountKeys").Index().Qual("github.com/gagliardetto/solana-go", "PublicKey"),
        ).
        Params(Id("Instruction"), Error()).
        BlockFunc(func(body *Group) {
            // Generate parser switch statement
        })
}
```

### Phase 4: Borsh Serialization (2-3 ng√†y)

#### 4.1. Marshal Methods
```go
func (g *Generator) generateMarshalMethods(typeName string, fields []IDLField) *Statement {
    return Func().
        Params(Id("obj").Op("*").Id(typeName)).
        Id("MarshalWithEncoder").
        Params(Id("encoder").Op("*").Qual("github.com/gagliardetto/binary", "Encoder")).
        Params(Error()).
        BlockFunc(func(body *Group) {
            for _, field := range fields {
                g.generateFieldMarshal(body, field)
            }
            body.Return(Nil())
        })
}
```

#### 4.2. Unmarshal Methods
```go
func (g *Generator) generateUnmarshalMethods(typeName string, fields []IDLField) *Statement {
    return Func().
        Params(Id("obj").Op("*").Id(typeName)).
        Id("UnmarshalWithDecoder").
        Params(Id("decoder").Op("*").Qual("github.com/gagliardetto/binary", "Decoder")).
        Params(Error()).
        BlockFunc(func(body *Group) {
            for _, field := range fields {
                g.generateFieldUnmarshal(body, field)
            }
            body.Return(Nil())
        })
}
```

### Phase 5: RPC Fetchers (1-2 ng√†y)

```go
// gen_fetchers.go
func (g *Generator) generateAccountFetcher(account IDLAccountDef) *Statement {
    accountType := toPascalCase(account.Name)
    
    return Func().Id(fmt.Sprintf("Fetch%s", accountType)).
        Params(
            Id("ctx").Qual("context", "Context"),
            Id("rpc").Op("*").Qual("github.com/gagliardetto/solana-go/rpc", "Client"),
            Id("address").Qual("github.com/gagliardetto/solana-go", "PublicKey"),
        ).
        Params(Op("*").Id(accountType), Error()).
        BlockFunc(func(body *Group) {
            // Implement fetch logic
        })
}
```

### Phase 6: Testing & Documentation (2 ng√†y)

#### 6.1. Generate Tests
```go
func (g *Generator) generateTests() error {
    file := NewFile(g.PackageName)
    
    // Add test imports
    file.ImportName("testing", "testing")
    file.ImportName("github.com/stretchr/testify/require", "require")
    
    // Generate roundtrip tests for each instruction
    for _, ix := range g.IDL.Instructions {
        file.Add(g.generateInstructionTest(ix))
    }
    
    return g.writeFile("generated_test.go", file)
}
```

#### 6.2. Generate Documentation
```go
func (g *Generator) generateDocs() error {
    var buf bytes.Buffer
    
    buf.WriteString("# Generated Code Documentation\n\n")
    buf.WriteString(fmt.Sprintf("Program: %s\n", g.IDL.Metadata.Name))
    buf.WriteString(fmt.Sprintf("Version: %s\n\n", g.IDL.Metadata.Version))
    
    // Document instructions
    buf.WriteString("## Instructions\n\n")
    for _, ix := range g.IDL.Instructions {
        buf.WriteString(fmt.Sprintf("### %s\n", ix.Name))
        // ... document params, accounts
    }
    
    return os.WriteFile(filepath.Join(g.OutputDir, "README.md"), buf.Bytes(), 0644)
}
```

## üìä Timeline T·ªïng Th·ªÉ

| Phase | Task | Duration | Priority |
|-------|------|----------|----------|
| 1 | Refactor Architecture | 2-3 days | **Critical** |
| 2 | Enhanced Type Support | 3-4 days | **High** |
| 3 | Instruction Builders | 2-3 days | **High** |
| 4 | Borsh Serialization | 2-3 days | **Medium** |
| 5 | RPC Fetchers | 1-2 days | **Low** |
| 6 | Testing & Docs | 2 days | **Medium** |
| **Total** | | **12-17 days** | |

## üéØ Success Metrics

### Code Quality
- [ ] Generated code passes `go vet`
- [ ] Generated code passes `golangci-lint`
- [ ] All types have proper Borsh tags
- [ ] All discriminators are correct

### Functionality
- [ ] Can build all instruction types
- [ ] Can parse all instruction types
- [ ] Can serialize/deserialize all types
- [ ] Can fetch accounts from RPC

### Testing
- [ ] >80% test coverage for generated code
- [ ] Roundtrip tests pass for all types
- [ ] Integration tests with real programs

### Documentation
- [ ] README for generated code
- [ ] Examples for each instruction
- [ ] API documentation

## üîó T√†i Li·ªáu Tham Kh·∫£o

1. **anchor-go Repository**
   - https://github.com/gagliardetto/anchor-go
   - Study: generator/, idl/, examples/

2. **Jennifer Code Generator**
   - https://github.com/dave/jennifer
   - Documentation: https://pkg.go.dev/github.com/dave/jennifer/jen

3. **Borsh Specification**
   - https://borsh.io/
   - Go implementation: github.com/gagliardetto/binary

4. **Anchor IDL Spec**
   - https://www.anchor-lang.com/docs/idl
   - https://github.com/coral-xyz/anchor/tree/master/idl/spec

## üí° Tips Tri·ªÉn Khai

1. **B·∫Øt ƒë·∫ßu nh·ªè**: Implement Phase 1 tr∆∞·ªõc, test k·ªπ, r·ªìi m·ªõi l√†m ti·∫øp
2. **Test-driven**: Vi·∫øt tests tr∆∞·ªõc khi implement features m·ªõi
3. **Incremental**: M·ªói PR n√™n focus v√†o 1 feature c·ª• th·ªÉ
4. **Documentation**: Document code generation logic r√µ r√†ng
5. **Examples**: Update examples sau m·ªói phase ƒë·ªÉ verify

## üéì B√†i H·ªçc Quan Tr·ªçng

1. **Type Safety l√† ch√¨a kh√≥a**: Jennifer gi√∫p code generation type-safe h∆°n nhi·ªÅu so v·ªõi string templates
2. **Separation of Concerns**: T√°ch generation logic cho t·ª´ng lo·∫°i file (instructions, accounts, events...)
3. **Borsh Serialization**: Ph·∫£i handle ƒë√∫ng format ƒë·ªÉ compatible v·ªõi Anchor
4. **Testing**: Auto-generated tests gi√∫p verify code generation logic
5. **Documentation**: Generated code c≈©ng c·∫ßn documentation t·ªët

---

**Next Steps**: B·∫Øt ƒë·∫ßu v·ªõi Phase 1 - Migrate sang Jennifer v√† refactor architecture.
