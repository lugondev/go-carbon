package gen

import (
	"fmt"

	"github.com/dave/jennifer/jen"
	"github.com/lugondev/go-carbon/internal/codegen"
)

// AccountsGenerator generates account type definitions.
type AccountsGenerator struct {
	*Generator
}

// NewAccountsGenerator creates a new accounts generator.
func NewAccountsGenerator(gen *Generator) *AccountsGenerator {
	return &AccountsGenerator{Generator: gen}
}

// Generate generates all account types from the IDL.
func (g *AccountsGenerator) Generate() error {
	if len(g.IDL.Accounts) == 0 {
		return nil
	}

	// Generate each account definition
	for _, accDef := range g.IDL.Accounts {
		if err := g.generateAccount(accDef); err != nil {
			return fmt.Errorf("failed to generate account %s: %w", accDef.Name, err)
		}
	}

	return nil
}

// generateAccount generates a single account type.
func (g *AccountsGenerator) generateAccount(accDef codegen.IDLAccountDef) error {
	accountName := FormatTypeName(accDef.Name)

	// Add documentation
	if len(accDef.Docs) > 0 {
		for _, doc := range FormatDocs(accDef.Docs) {
			g.File.Comment(doc)
		}
	}

	// Generate account struct
	if err := g.generateAccountStruct(accountName, accDef); err != nil {
		return err
	}

	// Generate discriminator constant
	g.generateAccountDiscriminator(accountName, accDef.Discriminator)

	// Generate Decode method
	if err := g.generateAccountDecode(accountName, accDef); err != nil {
		return err
	}

	g.File.Line()
	return nil
}

// generateAccountStruct generates the account struct type.
func (g *AccountsGenerator) generateAccountStruct(accountName string, accDef codegen.IDLAccountDef) error {
	// Check if account type is a struct
	if accDef.Type.Struct == nil {
		// If not a struct, it might be a type alias
		g.File.Type().Id(accountName).Add(g.ResolveType(&accDef.Type))
		g.File.Line()
		return nil
	}

	// Generate struct fields
	fields := make([]jen.Code, 0, len(accDef.Type.Struct.Fields))
	for _, field := range accDef.Type.Struct.Fields {
		fieldStmt := GenerateStructField(field, g.Generator)
		fields = append(fields, fieldStmt)
	}

	g.File.Type().Id(accountName).Struct(fields...)
	g.File.Line()

	return nil
}

// generateAccountDiscriminator generates the account discriminator constant.
func (g *AccountsGenerator) generateAccountDiscriminator(accountName string, disc []byte) {
	constName := accountName + "Discriminator"
	g.File.Var().Id(constName).Op("=").Add(DiscriminatorToBytes(disc))
	g.File.Line()
}

// generateAccountDecode generates the Decode method for accounts.
func (g *AccountsGenerator) generateAccountDecode(accountName string, accDef codegen.IDLAccountDef) error {
	discConst := accountName + "Discriminator"

	g.File.Comment(fmt.Sprintf("Decode%s decodes account data into %s.", accountName, accountName))
	g.File.Comment("It verifies the discriminator and deserializes the data using Borsh.")
	g.File.Func().Id("Decode"+accountName).Params(
		jen.Id("data").Index().Byte(),
	).Params(
		jen.Op("*").Id(accountName),
		jen.Error(),
	).Block(
		// Check minimum length (8 bytes discriminator)
		jen.If(jen.Len(jen.Id("data")).Op("<").Lit(8)).Block(
			jen.Return(jen.Nil(), jen.Qual("fmt", "Errorf").Call(jen.Lit("account data too short"))),
		),
		jen.Line(),

		// Verify discriminator
		jen.Id("discriminator").Op(":=").Id("data").Index(jen.Lit(0).Op(":").Lit(8)),
		jen.If(
			jen.Op("!").Qual("bytes", "Equal").Call(
				jen.Id("discriminator"),
				jen.Id(discConst),
			),
		).Block(
			jen.Return(jen.Nil(), jen.Qual("fmt", "Errorf").Call(
				jen.Lit(fmt.Sprintf("invalid discriminator for %s account", accountName)),
			)),
		),
		jen.Line(),

		// Decode account data
		jen.Var().Id("account").Id(accountName),
		jen.If(
			jen.Err().Op(":=").Qual("github.com/gagliardetto/binary", "UnmarshalBorsh").Call(
				jen.Op("&").Id("account"),
				jen.Id("data").Index(jen.Lit(8).Op(":")),
			),
			jen.Err().Op("!=").Nil(),
		).Block(
			jen.Return(jen.Nil(), jen.Qual("fmt", "Errorf").Call(
				jen.Lit("failed to decode account: %w"),
				jen.Err(),
			)),
		),
		jen.Line(),

		jen.Return(jen.Op("&").Id("account"), jen.Nil()),
	)
	g.File.Line()

	return nil
}

// GenerateAccountsFile generates the accounts.go file.
func GenerateAccountsFile(idl *codegen.IDL, packageName, outputDir string) error {
	gen := NewGenerator(idl, packageName)
	accGen := NewAccountsGenerator(gen)

	// Add file header comment
	gen.File.Comment("Code generated by go-carbon. DO NOT EDIT.")
	gen.File.Line()

	// Generate all accounts
	if err := accGen.Generate(); err != nil {
		return err
	}

	// Save to file
	filename := fmt.Sprintf("%s/accounts.go", outputDir)
	return gen.WriteToFile(filename)
}
