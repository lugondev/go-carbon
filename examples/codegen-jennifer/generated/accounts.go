package tokenswap

import (
	"bytes"
	"fmt"
	binary "github.com/gagliardetto/binary"
)

// Code generated by go-carbon. DO NOT EDIT.

type SwapPool struct {
	State         SwapState `borsh:"state" json:"state"`
	TokenAReserve uint64    `borsh:"token_a_reserve" json:"token_a_reserve"`
	TokenBReserve uint64    `borsh:"token_b_reserve" json:"token_b_reserve"`
}

var SwapPoolDiscriminator = []byte{uint8(0x1), uint8(0x2), uint8(0x3), uint8(0x4), uint8(0x5), uint8(0x6), uint8(0x7), uint8(0x8)}

// DecodeSwapPool decodes account data into SwapPool.
// It verifies the discriminator and deserializes the data using Borsh.
func DecodeSwapPool(data []byte) (*SwapPool, error) {
	if len(data) < 8 {
		return nil, fmt.Errorf("account data too short")
	}

	discriminator := data[0:8]
	if !bytes.Equal(discriminator, SwapPoolDiscriminator) {
		return nil, fmt.Errorf("invalid discriminator for SwapPool account")
	}

	var account SwapPool
	if err := binary.UnmarshalBorsh(&account, data[8:]); err != nil {
		return nil, fmt.Errorf("failed to decode account: %w", err)
	}

	return &account, nil
}
