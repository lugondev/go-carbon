package tokenswap

import (
	"bytes"
	"encoding/hex"
	"fmt"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Code generated by go-carbon. DO NOT EDIT.

type PoolInitializedEvent struct {
	Pool      solanago.PublicKey `borsh:"pool" json:"pool"`
	Authority solanago.PublicKey `borsh:"authority" json:"authority"`
	FeeRate   uint64             `borsh:"fee_rate" json:"fee_rate"`
}

var PoolInitializedEventDiscriminator = []byte{uint8(0x1e), uint8(0x1f), uint8(0x20), uint8(0x21), uint8(0x22), uint8(0x23), uint8(0x24), uint8(0x25)}

// DecodePoolInitializedEvent decodes event data into PoolInitializedEvent.
func DecodePoolInitializedEvent(data []byte) (*PoolInitializedEvent, error) {
	if len(data) < 8 {
		return nil, fmt.Errorf("event data too short")
	}

	discriminator := data[0:8]
	if !bytes.Equal(discriminator, PoolInitializedEventDiscriminator) {
		return nil, fmt.Errorf("invalid discriminator for PoolInitialized event")
	}

	var event PoolInitializedEvent
	if err := binary.UnmarshalBorsh(&event, data[8:]); err != nil {
		return nil, fmt.Errorf("failed to decode event: %w", err)
	}

	return &event, nil
}

type SwapExecutedEvent struct {
	User      solanago.PublicKey `borsh:"user" json:"user"`
	AmountIn  uint64             `borsh:"amount_in" json:"amount_in"`
	AmountOut uint64             `borsh:"amount_out" json:"amount_out"`
	Direction SwapDirection      `borsh:"direction" json:"direction"`
}

var SwapExecutedEventDiscriminator = []byte{uint8(0x28), uint8(0x29), uint8(0x2a), uint8(0x2b), uint8(0x2c), uint8(0x2d), uint8(0x2e), uint8(0x2f)}

// DecodeSwapExecutedEvent decodes event data into SwapExecutedEvent.
func DecodeSwapExecutedEvent(data []byte) (*SwapExecutedEvent, error) {
	if len(data) < 8 {
		return nil, fmt.Errorf("event data too short")
	}

	discriminator := data[0:8]
	if !bytes.Equal(discriminator, SwapExecutedEventDiscriminator) {
		return nil, fmt.Errorf("invalid discriminator for SwapExecuted event")
	}

	var event SwapExecutedEvent
	if err := binary.UnmarshalBorsh(&event, data[8:]); err != nil {
		return nil, fmt.Errorf("failed to decode event: %w", err)
	}

	return &event, nil
}

// ParseEvent parses an event from raw data.
// It uses the discriminator (first 8 bytes) to identify the event type.
func ParseEvent(data []byte) (interface{}, error) {
	if len(data) < 8 {
		return nil, fmt.Errorf("event data too short")
	}

	discriminator := data[0:8]

	switch hex.EncodeToString(discriminator) {
	case "1e1f202122232425":
		return DecodePoolInitializedEvent(data)
	case "28292a2b2c2d2e2f":
		return DecodeSwapExecutedEvent(data)
	default:
		return nil, fmt.Errorf("unknown event discriminator: %s", hex.EncodeToString(discriminator))
	}
}
