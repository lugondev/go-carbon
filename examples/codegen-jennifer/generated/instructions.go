package tokenswap

import (
	"encoding/hex"
	"fmt"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Code generated by go-carbon. DO NOT EDIT.

type InitializePoolInstruction struct {
	FeeRate  uint64 `borsh:"fee_rate" json:"fee_rate"`
	Accounts struct {
		SwapPool      solanago.PublicKey `json:"swap_pool"`
		Authority     solanago.PublicKey `json:"authority"`
		TokenAMint    solanago.PublicKey `json:"token_a_mint"`
		TokenBMint    solanago.PublicKey `json:"token_b_mint"`
		SystemProgram solanago.PublicKey `json:"system_program"`
	}
}

var InitializePoolInstructionDiscriminator = []byte{uint8(0xa), uint8(0xb), uint8(0xc), uint8(0xd), uint8(0xe), uint8(0xf), uint8(0x10), uint8(0x11)}

func NewInitializePoolInstruction(swapPool solanago.PublicKey, authority solanago.PublicKey, tokenAMint solanago.PublicKey, tokenBMint solanago.PublicKey, systemProgram solanago.PublicKey, feeRate uint64) *InitializePoolInstruction {
	return &InitializePoolInstruction{FeeRate: feeRate, Accounts: struct {
		SwapPool      solanago.PublicKey `json:"swap_pool"`
		Authority     solanago.PublicKey `json:"authority"`
		TokenAMint    solanago.PublicKey `json:"token_a_mint"`
		TokenBMint    solanago.PublicKey `json:"token_b_mint"`
		SystemProgram solanago.PublicKey `json:"system_program"`
	}{SwapPool: swapPool, Authority: authority, TokenAMint: tokenAMint, TokenBMint: tokenBMint, SystemProgram: systemProgram}}
}

// Build creates a Solana instruction from this instruction data.
func (ix *InitializePoolInstruction) Build() (*solanago.GenericInstruction, error) {
	if err := ix.ValidateAccounts(); err != nil {
		return nil, err
	}

	// Serialize instruction data
	data, err := binary.MarshalBorsh(ix)
	if err != nil {
		return nil, fmt.Errorf("failed to encode instruction: %w", err)
	}

	fullData := append(InitializePoolInstructionDiscriminator, data...)

	accounts := []*solanago.AccountMeta{&solanago.AccountMeta{PublicKey: ix.Accounts.SwapPool, IsWritable: true, IsSigner: false}, &solanago.AccountMeta{PublicKey: ix.Accounts.Authority, IsWritable: false, IsSigner: true}, &solanago.AccountMeta{PublicKey: ix.Accounts.TokenAMint, IsWritable: false, IsSigner: false}, &solanago.AccountMeta{PublicKey: ix.Accounts.TokenBMint, IsWritable: false, IsSigner: false}, &solanago.AccountMeta{PublicKey: ix.Accounts.SystemProgram, IsWritable: false, IsSigner: false}}

	return solanago.NewInstruction(ProgramID, accounts, fullData), nil
}

func (ix *InitializePoolInstruction) ValidateAccounts() error {
	return nil
}

type SwapInstruction struct {
	AmountIn         uint64        `borsh:"amount_in" json:"amount_in"`
	MinimumAmountOut uint64        `borsh:"minimum_amount_out" json:"minimum_amount_out"`
	Direction        SwapDirection `borsh:"direction" json:"direction"`
	Accounts         struct {
		SwapPool        solanago.PublicKey `json:"swap_pool"`
		User            solanago.PublicKey `json:"user"`
		UserSource      solanago.PublicKey `json:"user_source"`
		UserDestination solanago.PublicKey `json:"user_destination"`
		PoolSource      solanago.PublicKey `json:"pool_source"`
		PoolDestination solanago.PublicKey `json:"pool_destination"`
		TokenProgram    solanago.PublicKey `json:"token_program"`
	}
}

var SwapInstructionDiscriminator = []byte{uint8(0x14), uint8(0x15), uint8(0x16), uint8(0x17), uint8(0x18), uint8(0x19), uint8(0x1a), uint8(0x1b)}

func NewSwapInstruction(swapPool solanago.PublicKey, user solanago.PublicKey, userSource solanago.PublicKey, userDestination solanago.PublicKey, poolSource solanago.PublicKey, poolDestination solanago.PublicKey, tokenProgram solanago.PublicKey, amountIn uint64, minimumAmountOut uint64, direction SwapDirection) *SwapInstruction {
	return &SwapInstruction{AmountIn: amountIn, MinimumAmountOut: minimumAmountOut, Direction: direction, Accounts: struct {
		SwapPool        solanago.PublicKey `json:"swap_pool"`
		User            solanago.PublicKey `json:"user"`
		UserSource      solanago.PublicKey `json:"user_source"`
		UserDestination solanago.PublicKey `json:"user_destination"`
		PoolSource      solanago.PublicKey `json:"pool_source"`
		PoolDestination solanago.PublicKey `json:"pool_destination"`
		TokenProgram    solanago.PublicKey `json:"token_program"`
	}{SwapPool: swapPool, User: user, UserSource: userSource, UserDestination: userDestination, PoolSource: poolSource, PoolDestination: poolDestination, TokenProgram: tokenProgram}}
}

// Build creates a Solana instruction from this instruction data.
func (ix *SwapInstruction) Build() (*solanago.GenericInstruction, error) {
	if err := ix.ValidateAccounts(); err != nil {
		return nil, err
	}

	// Serialize instruction data
	data, err := binary.MarshalBorsh(ix)
	if err != nil {
		return nil, fmt.Errorf("failed to encode instruction: %w", err)
	}

	fullData := append(SwapInstructionDiscriminator, data...)

	accounts := []*solanago.AccountMeta{&solanago.AccountMeta{PublicKey: ix.Accounts.SwapPool, IsWritable: true, IsSigner: false}, &solanago.AccountMeta{PublicKey: ix.Accounts.User, IsWritable: false, IsSigner: true}, &solanago.AccountMeta{PublicKey: ix.Accounts.UserSource, IsWritable: true, IsSigner: false}, &solanago.AccountMeta{PublicKey: ix.Accounts.UserDestination, IsWritable: true, IsSigner: false}, &solanago.AccountMeta{PublicKey: ix.Accounts.PoolSource, IsWritable: true, IsSigner: false}, &solanago.AccountMeta{PublicKey: ix.Accounts.PoolDestination, IsWritable: true, IsSigner: false}, &solanago.AccountMeta{PublicKey: ix.Accounts.TokenProgram, IsWritable: false, IsSigner: false}}

	return solanago.NewInstruction(ProgramID, accounts, fullData), nil
}

func (ix *SwapInstruction) ValidateAccounts() error {
	return nil
}

// ParseInstruction parses an instruction from raw data.
// It uses the discriminator (first 8 bytes) to identify the instruction type.
func ParseInstruction(data []byte) (interface{}, error) {
	if len(data) < 8 {
		return nil, fmt.Errorf("instruction data too short")
	}

	discriminator := data[0:8]
	instructionData := data[8:]

	switch hex.EncodeToString(discriminator) {
	case "0a0b0c0d0e0f1011":
		var ix InitializePoolInstruction
		if err := binary.UnmarshalBorsh(&ix, instructionData); err != nil {
			return nil, err
		}
		return &ix, nil
	case "1415161718191a1b":
		var ix SwapInstruction
		if err := binary.UnmarshalBorsh(&ix, instructionData); err != nil {
			return nil, err
		}
		return &ix, nil
	default:
		return nil, fmt.Errorf("unknown instruction discriminator: %s", hex.EncodeToString(discriminator))
	}
}
